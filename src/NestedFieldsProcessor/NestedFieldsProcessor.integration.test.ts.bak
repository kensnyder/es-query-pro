import { afterAll, beforeAll, describe, expect, it } from 'bun:test';
import getEsClient from '../getEsClient/getEsClient';
import { NestedFieldsProcessor } from './NestedFieldsProcessor';

describe('NestedFieldsProcessor - Integration Tests', () => {
  const index = `test_nested_${Date.now()}`;
  const client = getEsClient();
  const processor = new NestedFieldsProcessor();

  beforeAll(async () => {
    // First, delete the index if it exists
    try {
      await client.indices.delete({ index });
    } catch (error) {
      // Ignore if index doesn't exist
    }

    // Create an index with nested mappings
    await client.indices.create({
      index,
      body: {
        mappings: {
          properties: {
            id: { type: 'keyword' },
            title: { type: 'text' },
            category: {
              type: 'nested',
              properties: {
                id: { type: 'keyword' },
                name: { type: 'text' },
              },
            },
            author: {
              type: 'nested',
              properties: {
                name: { type: 'text' },
                contact: {
                  type: 'nested',
                  properties: {
                    email: { type: 'keyword' },
                    phone: { type: 'keyword' },
                  },
                },
              },
            },
            metadata: {
      },
    });

    // Index some test documents
    await client.bulk({
      refresh: 'wait_for',
      body: [
        // Document 1
        { index: { _index: index, _id: '1' } },
        {
          id: '1',
          title: 'Test Document 1',
          category: {
            id: 'cat1',
            name: 'Category 1',
          },
          author: {
            name: 'John Doe',
            contact: {
              email: 'john@example.com',
              phone: '123-456-7890',
            },
          },
          metadata: {
            tags: ['important', 'test'],
            deleted: false,
          },
        },

        // Document 2
        { index: { _index: index, _id: '2' } },
        {
          id: '2',
          title: 'Test Document 2',
          category: {
            id: 'cat2',
            name: 'Category 2',
          },
          author: {
            name: 'Jane Smith',
            contact: {
              email: 'jane@example.com',
              phone: '098-765-4321',
            },
          },
          metadata: {
            tags: ['test'],
            deleted: false,
          },
        },

        // Document 3 (deleted)
        { index: { _index: index, _id: '3' } },
        {
          id: '3',
          title: 'Deleted Document',
          category: {
            id: 'cat1',
            name: 'Category 1',
          },
          author: {
            name: 'John Doe',
            contact: {
              email: 'john@example.com',
              phone: '123-456-7890',
            },
          },
          metadata: {
            tags: ['deleted'],
            deleted: true,
          },
        },
      ],
    });
  });

  afterAll(async () => {
    // Clean up
    try {
      await client.indices.delete({ index });
    } catch (error) {
      // Ignore
    }
  });

  it('should find documents by nested field', async () => {
    const query = {
      nested: {
        path: 'category',
        query: {
          term: { 'category.id': 'cat1' },
        },
      },
    };

    const result = await client.search({
      index,
      body: {
        query: query,
      },
    });

    expect(result.hits.hits).toHaveLength(2);
    expect(result.hits.hits.map((hit: any) => hit._id).sort()).toEqual([
      '1',
      '3',
    ]);
  });

  it('should find documents by multi-level nested field', async () => {
    const query = {
      nested: {
        path: 'author',
        query: {
          nested: {
            path: 'author.contact',
            query: {
              term: { 'author.contact.email': 'john@example.com' },
            },
          },
        },
      },
    };

    const result = await client.search({
      index,
      body: {
        query: query,
      },
    });

    expect(result.hits.hits).toHaveLength(2);
    expect(result.hits.hits.map((hit: any) => hit._id).sort()).toEqual([
      '1',
      '3',
    ]);
  });

  it('should find documents with must_not on nested field', async () => {
    const query = {
      bool: {
        must_not: [
          {
            nested: {
              path: 'metadata',
              query: {
                term: { 'metadata.deleted': true },
              },
            },
          },
        ],
      },
    };

    const result = await client.search({
      index,
      body: {
        query: query,
      },
    });

    expect(result.hits.hits).toHaveLength(2);
    expect(result.hits.hits.map((hit: any) => hit._id).sort()).toEqual([
      '1',
      '2',
    ]);
  });

  it('should handle bool query with multiple nested conditions', async () => {
    // First, verify the test data is as expected
    const allDocs = await client.search({
      index,
      body: {
        query: { match_all: {} },
      },
    });

    // The test is looking for a document where:
    // 1. category.id is 'cat1'
    // 2. author.name is 'John Doe'
    // 3. metadata.deleted is not true
    // This should match document with _id '1'

    const query = {
      bool: {
        must: [
          {
            nested: {
              path: 'category',
              query: {
                bool: {
                  must: [{ term: { 'category.id': 'cat1' } }],
                },
              },
            },
          },
          {
            nested: {
              path: 'author',
              query: {
                bool: {
                  must: [{ match: { 'author.name': 'John Doe' } }],
                },
              },
            },
          },
        ],
        must_not: [
          {
            nested: {
              path: 'metadata',
              query: {
                bool: {
                  must: [{ term: { 'metadata.deleted': true } }],
                },
              },
            },
          },
        ],
      },
    };

    const result = await client.search({
      index,
      body: {
        query: query,
        _source: false,
        fields: ['id'],
        size: 10,
      },
    });

    // Debug output
    console.log('Search results:', JSON.stringify(result.hits.hits, null, 2));

    // We expect document with _id '1' to match all conditions
    expect(result.hits.hits).toHaveLength(1);
    expect(result.hits.hits[0]._id).toBe('1');
  });

  it('should handle exists query on nested field', async () => {
    const query = {
      nested: {
        path: 'metadata',
        query: {
          exists: { field: 'metadata.tags' },
        },
      },
    };

    const result = await client.search({
      index,
      body: {
        query: query,
      },
    });

    // All three test documents have metadata.tags
    expect(result.hits.hits).toHaveLength(3);
  });

  it('should handle match query on nested field', async () => {
    const query = {
      nested: {
        path: 'author',
        query: {
          match: { 'author.name': 'John' },
        },
      },
    };

    const result = await client.search({
      index,
      body: {
        query: query,
      },
    });

    // Documents 1 and 3 have author.name 'John Doe'
    expect(result.hits.hits).toHaveLength(2);
    expect(result.hits.hits.map((hit: any) => hit._id).sort()).toEqual([
      '1',
      '3',
    ]);
  });
});
